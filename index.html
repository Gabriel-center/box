<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Calculadora de Treliça Box</title>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    :root{
      --bg:#003366; --ink:#FFFFFF; --card:#FFFFFF; --brand:#0055cc; --accent:#0077cc;
      --muted:#f0f0f0; --line:#0077cc; --shadow:0 6px 18px rgba(0,0,0,.12); --radius:12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:Arial,sans-serif; color:var(--ink); background:var(--bg);
      display:flex; justify-content:center; align-items:flex-start; margin:0; padding:16px;
    }

    .page{width:100%; max-width:1200px; display:grid; grid-template-columns:1fr; gap:16px}
    @media (min-width:980px){ .page{grid-template-columns:380px 1fr; gap:18px} }

    .panel{background:var(--card); color:var(--brand); border-radius:var(--radius); box-shadow:var(--shadow); padding:16px}
    .panel h1{margin:0 0 10px; font-size:22px; color:var(--accent); text-align:center}

    .row{display:grid; grid-template-columns:1fr; gap:8px; margin:10px 0}
    label{font-size:14px}
    select,input,button{
      width:100%; padding:12px; border-radius:8px; border:1px solid var(--line); background:#fff; color:#000; font-size:14px;
    }
    input[type="range"]{accent-color:var(--accent)}
    .inline{display:grid; grid-template-columns:1fr 140px; gap:10px; align-items:center}

    .actions{display:flex; gap:10px; margin-top:10px; flex-wrap:wrap}
    .actions .grow{flex:1; min-width:180px}
    button.primary{background:var(--accent); color:#fff; border:1px solid var(--accent); cursor:pointer}
    button.primary:disabled{opacity:.6; cursor:not-allowed}

    @media (max-width:640px){
      .panel{padding:12px}
      .inline{grid-template-columns:1fr}
      select,input,button{padding:10px; font-size:16px}
      .actions{gap:8px}
    }

    #snapNote{font-size:12px; color:#333; min-height:18px}

    .export-card{background:#fff; border:1px solid var(--muted); border-radius:var(--radius); padding:12px; color:#000}
    .export-header{display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap}
    .export-title{font-weight:bold; color:#000}
    .export-header input{flex:1 1 280px; border:1px solid var(--line); padding:10px; border-radius:8px; min-width:200px}

    .preview-wrap{display:grid; grid-template-columns:1fr; gap:12px}
    #gridWrap{overflow:hidden; border:1px solid #ddd; border-radius:10px; padding:8px; background:#fff; min-height:220px}
    #grid{position:relative; width:100%}

    #results{background:var(--muted); border-radius:10px; padding:12px; color:#000; font-size:16px}
    .results-title{
      display:flex; align-items:center; gap:8px; margin:2px 0 10px;
    }
    .results-title .t-left{
      font-size:18px; font-weight:800; color:var(--accent);
      text-transform:uppercase; letter-spacing:.5px;
    }
    .results-title .title-rule{ flex:1; height:1px; background:var(--line); opacity:.35; }
    .results-title .t-meta{ font-weight:700; color:#222; white-space:nowrap; }

    .checklist{
      display:grid;
      grid-template-columns:repeat(2, minmax(0,1fr));
      gap:12px 16px;
      margin-top:10px;
    }
    .checklist-item{
      display:flex; align-items:center; gap:10px; cursor:pointer;
      user-select:none;
    }
    .checklist-item .sw{width:32px; height:32px; display:inline-block; flex:0 0 32px}
    .checklist-item label{flex:1}
    .checklist-item.off label{text-decoration:line-through; color:#666}
    .checklist-item.off .sw{opacity:.45}

    @media (max-width:520px){
      .checklist{grid-template-columns:1fr}
    }

    details{margin-top:12px; background:var(--muted); padding:10px 12px; border-radius:10px; color:#000}
    summary{cursor:pointer; font-weight:600; color:#000}
  </style>
</head>
<body>
  <div class="page">
    <section class="panel" aria-labelledby="calc-title">
      <h1 id="calc-title">Calculadora de Treliça Box</h1>

      <div class="row">
        <label for="width">Largura do perfil (metros)</label>
        <select id="width" aria-describedby="width-help">
          <option value="0.25" selected>0.25</option>
          <option value="0.15">0.15</option>
        </select>
        <small id="width-help" style="color:#2b2b2b">O passo dos controles segue esta largura.</small>
      </div>

      <div class="row">
        <label>Comprimento (metros)</label>
        <div class="inline">
          <input aria-label="Comprimento (slider)" type="range" id="lengthRange" min="0" max="5" step="0.25" value="0">
          <input aria-label="Comprimento (número)" type="number" id="lengthNum" min="0" step="0.25" value="0" inputmode="decimal" placeholder="ex.: 8">
        </div>
      </div>

      <div class="row">
        <label>Altura (metros)</label>
        <div class="inline">
          <input aria-label="Altura (slider)" type="range" id="heightRange" min="0" max="5" step="0.25" value="0">
          <input aria-label="Altura (número)" type="number" id="heightNum" min="0" step="0.25" value="0" inputmode="decimal" placeholder="ex.: 3.5">
        </div>
      </div>

      <div id="snapNote"></div>

      <div class="actions">
        <button id="calcBtn" class="primary grow">Calcular grade e materiais</button>
        <button id="resetBtn" class="grow" title="Limpar">Limpar</button>
      </div>
    </section>

    <section class="panel">
      <div class="export-card" id="exportCard">
        <div class="export-header">
          <span class="export-title">Evento/OS:</span>
          <input id="eventInput" type="text" placeholder="Opcional — título do cartão">
        </div>

        <div class="preview-wrap">
          <div id="gridWrap" aria-live="polite" aria-label="Prévia da treliça">
            <div id="grid"></div>
          </div>

        <div id="results" aria-label="Lista de materiais"></div>
        </div>
      </div>

      <div class="actions">
        <button id="downloadBtn" class="primary grow">Baixar cartão como PNG</button>
      </div>

      <details>
        <summary>Informações de depuração</summary>
        <div id="debugInfo" style="font-family:monospace; font-size:12px; white-space:pre-wrap;"></div>
      </details>
    </section>
  </div>

  <script>
    const VIEWPORT_CAP = 0.8;

    const state = { trussWidth:0.25, height:0, length:0, pxPerMeter:100, borderMarginPx:1, lastNW:0, lastNH:0 };
    const el = id => document.getElementById(id);
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const near = (a,b,eps=1e-6)=>Math.abs(a-b)<eps;
    const fmt = n => Number(n).toLocaleString('pt-BR',{maximumFractionDigits:2});
    const fmtInt = n => Number(n).toLocaleString('pt-BR',{maximumFractionDigits:0});
    const fmtMShort = n => `${Number(n).toLocaleString('pt-BR',{maximumFractionDigits:2})}m`;

    function syncStepsFromWidth(){
      const s=parseFloat(el('width').value);
      ['heightRange','lengthRange','heightNum','lengthNum'].forEach(id=>el(id).step=s);
    }

    function setHeightFromSlider(v){ const val = clamp(parseFloat(v)||0, 0, 5); state.height = val; el('heightRange').value = val; el('heightNum').value = val; }
    function setHeightFromNumber(v){ const val = Math.max(0, parseFloat(v)||0); state.height = val; el('heightNum').value = val; el('heightRange').value = Math.min(5, val); }
    function setLengthFromSlider(v){ const val = clamp(parseFloat(v)||0, 0, 5); state.length = val; el('lengthRange').value = val; el('lengthNum').value = val; }
    function setLengthFromNumber(v){ const val = Math.max(0, parseFloat(v)||0); state.length = val; el('lengthNum').value = val; el('lengthRange').value = Math.min(5, val); }

    // ---------- Solver de construtibilidade ----------
    // Passo base 0,05 m (m.d.c. de 2, 1, 0,5 e 0,25 / 0,15)
    const STEP = 0.05;
    function toUnits(m){ return Math.max(0, Math.floor((m + 1e-9)/STEP)); }
    function fromUnits(u){ return u * STEP; }

    function maxConstructiblePieces(targetMeters, sizesMeters){
      const den = sizesMeters.map(s => Math.round(s/STEP)); // ex: [40,20,10,5] ou [40,20,10,3]
      const T = toUnits(targetMeters);
      const dp = new Array(T+1).fill(false);
      const prev = new Array(T+1).fill(-1); // qual moeda usei por último
      dp[0] = true;
      for(let i=1;i<=T;i++){
        for(let k=0;k<den.length;k++){
          const d = den[k];
          if (i - d >= 0 && dp[i - d]){
            dp[i] = true; prev[i] = k; break;
          }
        }
      }
      let best = T;
      while(best >= 0 && !dp[best]) best--;
      if (best < 0) return { length:0, pieces:[] };

      // reconstrói uma lista de peças (ordem arbitrária)
      const pieces = [];
      let u = best;
      while(u > 0){
        const k = prev[u];
        if (k < 0) break; // robustez
        pieces.push({ meters: den[k]*STEP }); // guardo o tamanho em metros
        u -= den[k];
      }
      // ordena decrescente só para ficar mais bonito no desenho
      pieces.sort((a,b)=>b.meters - a.meters);
      return { length: fromUnits(best), pieces };
    }

    // Particiona peças reais em trechos ≤ 4 m, buscando equilíbrio
    function partitionPiecesEven(pieces, segMin, maxPer=4, tol=0.25){
      const total = pieces.reduce((a,p)=>a+p.meters, 0);
      if (total === 0) return { groups:[], boundaries:[], target:0 };
      let target = total / segMin; if (target > maxPer) target = maxPer;

      const groups = [];
      let cur = []; let curSum = 0;
      for (const p of pieces){
        if (curSum + p.meters <= maxPer && (curSum + p.meters) <= (target + tol)){
          cur.push(p); curSum += p.meters;
        } else {
          if (cur.length === 0){ cur.push(p); curSum += p.meters; }
          else { groups.push(cur); cur=[p]; curSum=p.meters; }
        }
      }
      if (cur.length) groups.push(cur);

      // se faltaram grupos, corta grupos grandes em fronteiras de peça
      while (groups.length < segMin){
        let idx = 0, bestLen = 0;
        for (let i=0;i<groups.length;i++){
          const L = groups[i].reduce((a,p)=>a+p.meters,0);
          if (L > bestLen && groups[i].length > 1){ bestLen = L; idx = i; }
        }
        if (bestLen === 0) break;
        const g = groups[idx];
        const half = bestLen/2;
        let acc = 0, cut = 1;
        for (let j=0;j<g.length;j++){
          if (acc + g[j].meters > half) { cut = j; break; }
          acc += g[j].meters; cut = j+1;
        }
        const g1 = g.slice(0,cut), g2 = g.slice(cut);
        const L1 = g1.reduce((a,p)=>a+p.meters,0), L2 = g2.reduce((a,p)=>a+p.meters,0);
        if (L1>0 && L2>0 && L1<=maxPer && L2<=maxPer) groups.splice(idx,1,g1,g2); else break;
      }

      // se sobrou demais, tenta juntar adjacentes sem passar de 4m
      let changed = true;
      while (groups.length > segMin && changed){
        changed = false;
        for (let i=0;i<groups.length-1;i++){
          const L1 = groups[i].reduce((a,p)=>a+p.meters,0);
          const L2 = groups[i+1].reduce((a,p)=>a+p.meters,0);
          if (L1 + L2 <= maxPer){
            groups.splice(i,2, groups[i].concat(groups[i+1]));
            changed = true; break;
          }
        }
      }

      const boundaries = [];
      let accM = 0;
      for (let i=0;i<groups.length-1;i++){
        const L = groups[i].reduce((a,p)=>a+p.meters,0);
        accM += L; boundaries.push(accM);
      }
      return { groups, boundaries, target };
    }

    // ---------- SVG ----------
    const SVGNS = 'http://www.w3.org/2000/svg';
    function makePatternDefs(){
      const defs = document.createElementNS(SVGNS,'defs');
      defs.innerHTML = `
        <pattern id="patRed" patternUnits="userSpaceOnUse" width="12" height="12">
          <path d="M-3,12 L12,-3 M0,15 L15,0" stroke="rgba(0,0,0,0.22)" stroke-width="4"/>
        </pattern>
        <pattern id="patOrange" patternUnits="userSpaceOnUse" width="10" height="10">
          <path d="M0,0 L0,10 M0,0 L10,0" stroke="rgba(0,0,0,0.18)" stroke-width="2"/>
        </pattern>
        <pattern id="patGreen" patternUnits="userSpaceOnUse" width="16" height="16">
          <circle cx="5" cy="5" r="2.5" fill="rgba(0,0,0,0.25)"/>
        </pattern>
        <pattern id="patBlue" patternUnits="userSpaceOnUse" width="16" height="16">
          <path d="M-4,16 L16,-4 M0,20 L20,0" stroke="rgba(255,255,255,0.28)" stroke-width="3"/>
        </pattern>`;
      return defs;
    }
    function baseColor(code){ return code==='8'?'#FF0000':code==='4'?'#ff6600':code==='2'?'#008000':code==='1'?'#0000FF':'#FFFFFF'; }
    function patId(code){ return code==='8'?'#patRed':code==='4'?'#patOrange':code==='2'?'#patGreen':code==='1'?'#patBlue':null; }
    function addPiece(svg, x,y,w,h, code){
      const g = document.createElementNS(SVGNS,'g');
      const r1 = document.createElementNS(SVGNS,'rect'); r1.setAttribute('x',x); r1.setAttribute('y',y); r1.setAttribute('width',w); r1.setAttribute('height',h); r1.setAttribute('fill', baseColor(code));
      g.appendChild(r1);
      const pid = patId(code);
      if(pid){ const r2 = document.createElementNS(SVGNS,'rect'); r2.setAttribute('x',x); r2.setAttribute('y',y); r2.setAttribute('width',w); r2.setAttribute('height',h); r2.setAttribute('fill', `url(${pid})`); g.appendChild(r2); }
      const r3 = document.createElementNS(SVGNS,'rect'); r3.setAttribute('x',x+0.5); r3.setAttribute('y',y+0.5); r3.setAttribute('width',w-1); r3.setAttribute('height',h-1); r3.setAttribute('fill','none'); r3.setAttribute('stroke','#aaa'); r3.setAttribute('stroke-width','1');
      g.appendChild(r3);
      svg.appendChild(g);
    }

    // ---------- Layout ----------
    function boxMetrics(elm, view=window){
      const cs = view.getComputedStyle(elm);
      const padL = parseFloat(cs.paddingLeft)||0, padR = parseFloat(cs.paddingRight)||0;
      const padT = parseFloat(cs.paddingTop)||0,  padB = parseFloat(cs.paddingBottom)||0;
      const borL = parseFloat(cs.borderLeftWidth)||0, borR = parseFloat(cs.borderRightWidth)||0;
      const borT = parseFloat(cs.borderTopWidth)||0,  borB = parseFloat(cs.borderBottomWidth)||0;
      const contentW = elm.clientWidth - padL - padR;
      return {padL,padR,padT,padB,borL,borR,borT,borB,contentW};
    }
    function sizeSVGToFit(svg, nW, nH){
      const wrap = el('gridWrap');
      const card = el('exportCard');
      const m = boxMetrics(wrap);
      let scale = m.contentW / nW;
      const capH = window.innerHeight * VIEWPORT_CAP;
      const totalH = nH * scale + m.padT + m.padB + m.borT + m.borB;
      if (totalH > capH) scale = (capH - (m.padT + m.padB + m.borT + m.borB)) / nH;
      const targetW = Math.max(1, Math.round(nW * scale));
      const targetH = Math.max(1, Math.round(nH * scale));
      svg.setAttribute('width', targetW); svg.setAttribute('height', targetH);
      wrap.style.minHeight = (targetH + m.padT + m.padB) + 'px'; wrap.style.overflow = 'hidden';
      wrap.dataset.scale = String(scale);
      wrap.dataset.nw = String(nW); wrap.dataset.nh = String(nH);
      wrap.dataset.tW = String(targetW); wrap.dataset.tH = String(targetH);
      wrap.dataset.padT = String(m.padT); wrap.dataset.padB = String(m.padB);
      wrap.dataset.padL = String(m.padL); wrap.dataset.padR = String(m.padR);
      wrap.dataset.borL = String(m.borL); wrap.dataset.borR = String(m.borR);
      wrap.dataset.cardW = String(card.getBoundingClientRect().width);
    }

    function gerarGrade(){
      const q = parseFloat(el('width').value);
      const sizes = [2,1,0.5,q];

      const Hext = state.height;
      const Wext = state.length;

      const PPM = state.pxPerMeter;
      const m = state.borderMarginPx;

      // Alvos internos (não-negativos)
      const targetInnerL = Math.max(0, Wext - 2*q);
      const targetInnerV = Math.max(0, Hext - 2*q);

      // Solver: máximo construível ≤ alvo
      const { length: innerL, pieces: hPiecesAll } = maxConstructiblePieces(targetInnerL, sizes);
      const { length: innerV, pieces: vPieces }     = maxConstructiblePieces(targetInnerV, sizes);

      const Wused = 2*q + innerL;
      const Hused = 2*q + innerV;

      // Aviso
      const note = [];
      if (!near(Wused, Wext)) note.push(`Comprimento ajustado de ${fmt(Wext)} m para ${fmt(Wused)} m montável`);
      if (!near(Hused, Hext)) note.push(`Altura ajustada de ${fmt(Hext)} m para ${fmt(Hused)} m montável`);
      el('snapNote').textContent = note.join(' · ');

      // Segmentação por construtibilidade: grupos de peças ≤ 4m
      const segMin = Math.max(1, Math.ceil((Wused + 1e-9) / 4));
      const { groups, boundaries } = partitionPiecesEven(hPiecesAll, segMin, 4, 0.25);
      const supports = Math.max(0, groups.length - 1);

      // Medidas em px
      const cornerPx = q * PPM;
      const innerPxX = innerL * PPM;
      const innerPxY = innerV * PPM;
      const nW = 2*cornerPx + innerPxX + 2*m;
      const nH = 2*cornerPx + innerPxY + 2*m;
      state.lastNW = nW; state.lastNH = nH;

      // SVG
      const grid = el('grid'); grid.innerHTML='';
      const svg = document.createElementNS(SVGNS,'svg');
      svg.setAttribute('viewBox', `0 0 ${nW} ${nH}`);
      svg.setAttribute('preserveAspectRatio','xMinYMin meet');
      svg.appendChild(makePatternDefs());
      grid.appendChild(svg);

      const topY = m, bottomY = m + cornerPx + innerPxY;
      const leftX = m, rightX  = m + cornerPx + innerPxX;

      // Cantos
      addPiece(svg, leftX, topY, cornerPx, cornerPx, '1');
      addPiece(svg, rightX, topY, cornerPx, cornerPx, '1');
      addPiece(svg, leftX, bottomY, cornerPx, cornerPx, '1');
      addPiece(svg, rightX, bottomY, cornerPx, cornerPx, '1');

      // Topo/Base caminhando grupos
      let xTop = leftX + cornerPx;
      groups.forEach(group=>{
        group.forEach(p=>{
          const wpx = p.meters * PPM;
          const code = p.meters>=1.9999?'8':p.meters>=0.9999?'4':p.meters>=0.4999?'2':'1';
          addPiece(svg, xTop, topY, wpx, cornerPx, code);
          addPiece(svg, xTop, bottomY, wpx, cornerPx, code);
          xTop += wpx;
        });
      });

      // Coluna helper
      function drawColumn(x){
        let y = topY + cornerPx;
        vPieces.forEach(p=>{
          const hp = p.meters * PPM;
          const code = p.meters>=1.9999?'8':p.meters>=0.9999?'4':p.meters>=0.4999?'2':'1';
          addPiece(svg, x, y, cornerPx, hp, code);
          y += hp;
        });
      }
      // Laterais
      drawColumn(leftX);
      drawColumn(rightX);

      // Miolo
      if (innerPxX > 0 && innerPxY > 0){
        addPiece(svg, leftX + cornerPx, topY + cornerPx, innerPxX, innerPxY, '0');
      }

      // Suportes nas fronteiras de grupos
      boundaries.forEach(bm=>{
        const x = leftX + cornerPx + bm * PPM;
        drawColumn(x);
        addPiece(svg, x, topY, cornerPx, cornerPx, '1');
        addPiece(svg, x, bottomY, cornerPx, cornerPx, '1');
      });

      sizeSVGToFit(svg, nW, nH);

      // ===== Materiais (conta por comprimentos efetivos) =====
      const totals = {}; sizes.forEach(s=>totals[s]=0);

      // Verticais: colunas * peças(v)
      const colunas = supports + 2;
      const vQuant = {};
      sizes.forEach(s=>vQuant[s]=0);
      vPieces.forEach(p=>{ vQuant[p.meters] = (vQuant[p.meters]||0) + 1; });
      sizes.forEach(s=>{ totals[s] += colunas * (vQuant[s]||0); });

      // Horizontais: soma por grupo (topo + base)
      const hQuant = {};
      sizes.forEach(s=>hQuant[s]=0);
      groups.forEach(g=> g.forEach(p=>{ hQuant[p.meters] = (hQuant[p.meters]||0) + 1; }));
      sizes.forEach(s=>{ totals[s] += 2 * (hQuant[s]||0); });

      // Cantos
      totals[q] = (totals[q]||0) + 4;

      // Pés e pesos
      const feetCount = colunas;
      const weightCount = colunas * 2;

      // Swatches/Ícones
      const sw = (code,side=32)=>(
        `<svg xmlns="http://www.w3.org/2000/svg" width="${side}" height="${side}" viewBox="0 0 ${side} ${side}">
           <defs>
             <pattern id="p1" patternUnits="userSpaceOnUse" width="12" height="12"><path d="M-3,12 L12,-3 M0,15 L15,0" stroke="rgba(0,0,0,0.22)" stroke-width="4"/></pattern>
             <pattern id="p2" patternUnits="userSpaceOnUse" width="10" height="10"><path d="M0,0 L0,10 M0,0 L10,0" stroke="rgba(0,0,0,0.18)" stroke-width="2"/></pattern>
             <pattern id="p3" patternUnits="userSpaceOnUse" width="16" height="16"><circle cx="5" cy="5" r="2.5" fill="rgba(0,0,0,0.25)"/></pattern>
             <pattern id="p4" patternUnits="userSpaceOnUse" width="16" height="16"><path d="M-4,16 L16,-4 M0,20 L20,0" stroke="rgba(255,255,255,0.28)" stroke-width="3"/></pattern>
           </defs>
           <rect width="${side}" height="${side}" fill="${baseColor(code)}"/>
           <rect width="${side}" height="${side}" fill="url(#${code==='8'?'p1':code==='4'?'p2':code==='2'?'p3':'p4'})"/>
           <rect x="0.5" y="0.5" width="${side-1}" height="${side-1}" fill="none" stroke="#777" stroke-width="1"/>
         </svg>`
      );
      const footIcon = (side=32)=>(
        `<svg xmlns="http://www.w3.org/2000/svg" width="${side}" height="${side}" viewBox="0 0 28 28">
          <rect x="5" y="5" width="6" height="16" fill="#555"/>
          <rect x="3" y="20" width="22" height="4" rx="1" ry="1" fill="#333"/>
          <circle cx="8" cy="9" r="2" fill="#999"/>
          <rect x="0.5" y="0.5" width="27" height="27" fill="none" stroke="#777" stroke-width="1"/>
        </svg>`
      );
      const weightIcon = (side=32)=>(
        `<svg xmlns="http://www.w3.org/2000/svg" width="${side}" height="${side}" viewBox="0 0 28 28">
          <rect x="6" y="12" width="16" height="4" rx="1" ry="1" fill="#444"/>
          <rect x="3" y="9" width="4" height="10" rx="1" ry="1" fill="#666"/>
          <rect x="21" y="9" width="4" height="10" rx="1" ry="1" fill="#666"/>
          <rect x="0.5" y="0.5" width="27" height="27" fill="none" stroke="#777" stroke-width="1"/>
        </svg>`
      );

      const qLabel = `Q${Math.round(q*100)}`;
      const meta = `${fmtMShort(Wused)} × ${fmtMShort(Hused)}`;
      let list = `
        <div class="results-title">
          <span class="t-left">Materiais</span>
          <span class="title-rule"></span>
          <span class="t-meta" id="resultsMeta">${qLabel} ${meta}</span>
        </div>
        <div class="checklist">`;

      const orderedAll = [q, 0.5, 1, 2].sort((a,b)=>a-b);
      orderedAll.forEach(size=>{
        const qnt = totals[size] || 0;
        const code = size>=2?'8':size>=1?'4':size>=0.5?'2':'1';
        list += `
          <div class="checklist-item" onclick="toggleItem(this)" role="button" tabindex="0">
            <span class="sw">${sw(code,32)}</span>
            <label>${fmtInt(qnt)} unidades de ${fmt(size)} metros</label>
          </div>`;
      });

      list += `
        <div class="checklist-item" onclick="toggleItem(this)" role="button" tabindex="0">
          <span class="sw">${footIcon(32)}</span>
          <label>${fmtInt(feetCount)} Pés (0,5)</label>
        </div>
        <div class="checklist-item" onclick="toggleItem(this)" role="button" tabindex="0">
          <span class="sw">${weightIcon(32)}</span>
          <label>${fmtInt(weightCount)} Pesos</label>
        </div>`;

      list += '</div>';

      el('results').innerHTML = list;
    }

    function toggleItem(node){ node.classList.toggle('off'); }

    // ---------- Download idêntico ao que você vê ----------
    function baixarCartao(){
      const card = el('exportCard');
      const wrapLive = el('gridWrap');
      let rawTitle = (el('eventInput').value || '').trim();
      if (!rawTitle) rawTitle = 'Qcoisa';
      const titulo = rawTitle.replace(/[^\w\-]+/g,'_');

      const tW  = parseFloat(wrapLive.dataset.tW)||0;
      const tH  = parseFloat(wrapLive.dataset.tH)||0;
      const padT= parseFloat(wrapLive.dataset.padT)||0;
      const padB= parseFloat(wrapLive.dataset.padB)||0;
      const padL= parseFloat(wrapLive.dataset.padL)||0;
      const padR= parseFloat(wrapLive.dataset.padR)||0;
      const borL= parseFloat(wrapLive.dataset.borL)||0;
      const borR= parseFloat(wrapLive.dataset.borR)||0;
      const cardW = parseFloat(wrapLive.dataset.cardW) || card.getBoundingClientRect().width;

      html2canvas(card, {
        backgroundColor:'#FFFFFF',
        scale: window.devicePixelRatio || 2,
        useCORS:true,
        onclone: (doc)=>{
          const cloneCard = doc.getElementById('exportCard');
          const wrap = cloneCard.querySelector('#gridWrap');
          const grid = cloneCard.querySelector('#grid');
          const svg  = grid.querySelector('svg');
          if(!svg) return;

          doc.documentElement.style.width = cardW + 'px';
          doc.body.style.width = cardW + 'px';
          cloneCard.style.width = cardW + 'px';

          svg.setAttribute('width',  tW);
          svg.setAttribute('height', tH);
          wrap.style.width = (tW + padL + padR + borL + borR) + 'px';
          wrap.style.minHeight = (tH + padT + padB) + 'px';
          wrap.style.overflow = 'hidden';
        }
      }).then(canvas=>{
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = `${titulo}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    }

    // Eventos
    el('width').addEventListener('change', ()=>{ state.trussWidth=parseFloat(el('width').value); syncStepsFromWidth(); });
    el('heightRange').addEventListener('input', e=> setHeightFromSlider(e.target.value));
    el('heightNum').addEventListener('input',   e=> setHeightFromNumber(e.target.value));
    el('lengthRange').addEventListener('input', e=> setLengthFromSlider(e.target.value));
    el('lengthNum').addEventListener('input',   e=> setLengthFromNumber(e.target.value));

    el('calcBtn').addEventListener('click', ()=>{ gerarGrade(); requestAnimationFrame(gerarGrade); });
    el('resetBtn').addEventListener('click', ()=>{
      setHeightFromNumber(0); setLengthFromNumber(0);
      el('grid').innerHTML=''; el('results').innerHTML=''; el('eventInput').value='';
      el('gridWrap').style.minHeight = '220px';
      el('snapNote').textContent='';
    });
    el('downloadBtn').addEventListener('click', baixarCartao);

    window.addEventListener('resize', ()=>{
      const grid = el('grid'); const svg = grid.querySelector('svg');
      if (!svg || !state.lastNW || !state.lastNH) return;
      sizeSVGToFit(svg, state.lastNW, state.lastNH);
    });

    (function(){
      syncStepsFromWidth();
      setLengthFromNumber(0);
      setHeightFromNumber(0);
    })();
  </script>
</body>
</html>
