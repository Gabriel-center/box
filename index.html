v      return piece;
    }

    // Fit grid into container by scaling if needed
    function fitGridToWrap(naturalW, naturalH){
      const wrap = el('gridWrap');
      const padding = 20; // breathing room
      const availW = wrap.clientWidth - padding;
      // Height budget depends on media query; compute from actual
      const availH = wrap.clientHeight - padding || 440;
      const sx = availW / naturalW;
      const sy = availH / naturalH;
      const scale = Math.min(1, sx, sy);
      const grid = el('grid');
      grid.style.width = naturalW + 'px';
      grid.style.height = naturalH + 'px';
      grid.style.transform = 'scale(' + scale + ')';
      // Adjust wrapper min height to keep content visible
      const usedH = Math.min(naturalH * scale + 12, Math.max(availH, 220));
      wrap.style.minHeight = usedH + 'px';
    }

    // Build grid and results
    function generateGrid(){
      const widthVal = parseFloat(el('width').value);
      const heightVal = state.height;
      const lengthVal = state.length;

      const resultsEl = el('results');
      resultsEl.innerHTML = '';

      if(lengthVal < widthVal*2 || heightVal < widthVal*2){
        resultsEl.innerHTML =
          '<div><strong>Tip:</strong> length and height must be at least 2× the truss width to form a rectangle.</div>';
      }

      // internal spans
      let innerL = Math.max(0, lengthVal - widthVal*2);
      let innerH = Math.max(0, heightVal - widthVal*2);

      const materialSizes = [2, 1, 0.5, widthVal];

      const qL = calculateMaterialNeeded(innerL, materialSizes);
      const qH = calculateMaterialNeeded(innerH, materialSizes);

      const topPieces    = getDistributionArray(qL, widthVal);
      const bottomPieces = getDistributionArray(qL, widthVal);
      const leftPieces   = getDistributionArray(qH, widthVal);
      const rightPieces  = getDistributionArray(qH, widthVal);

      let cellsX = 2; // two corners
      topPieces.forEach(p=>cellsX += p.cells);
      let cellsY = 2;
      leftPieces.forEach(p=>cellsY += p.cells);

      const cellSize = state.cellPxPerMeter * widthVal; // px per truss width
      const m = state.borderMarginPx;
      const naturalW = cellsX * cellSize + 2*m;
      const naturalH = cellsY * cellSize + 2*m;

      const grid = el('grid');
      grid.innerHTML = '';

      // Corners
      grid.appendChild(createPiece(m, m, cellSize, cellSize, '1'));
      grid.appendChild(createPiece(m + (cellsX-1)*cellSize, m, cellSize, cellSize, '1'));
      grid.appendChild(createPiece(m, m + (cellsY-1)*cellSize, cellSize, cellSize, '1'));
      grid.appendChild(createPiece(m + (cellsX-1)*cellSize, m + (cellsY-1)*cellSize, cellSize, cellSize, '1'));

      // Top border
      let x = m + cellSize;
      topPieces.forEach(p=>{
        const w = p.cells * cellSize;
        grid.appendChild(createPiece(x, m, w, cellSize, p.code));
        x += w;
      });

      // Bottom border
      x = m + cellSize;
      let yBottom = m + (cellsY-1)*cellSize;
      bottomPieces.forEach(p=>{
        const w = p.cells * cellSize;
        grid.appendChild(createPiece(x, yBottom, w, cellSize, p.code));
        x += w;
      });

      // Left border
      let y = m + cellSize;
      leftPieces.forEach(p=>{
        const h = p.cells * cellSize;
        grid.appendChild(createPiece(m, y, cellSize, h, p.code));
        y += h;
      });

      // Right border
      y = m + cellSize;
      let xRight = m + (cellsX-1)*cellSize;
      rightPieces.forEach(p=>{
        const h = p.cells * cellSize;
        grid.appendChild(createPiece(xRight, y, cellSize, h, p.code));
        y += h;
      });

      // Inner fill
      const inner = document.createElement('div');
      inner.className = 'truss-piece color-0';
      inner.style.left = (m + cellSize) + 'px';
      inner.style.top  = (m + cellSize) + 'px';
      inner.style.width  = ((cellsX-2)*cellSize) + 'px';
      inner.style.height = ((cellsY-2)*cellSize) + 'px';
      grid.appendChild(inner);

      // Fit to wrap
      fitGridToWrap(naturalW, naturalH);

      // Materials checklist
      const totals = {};
      materialSizes.forEach(s=>{
        totals[s] = 2 * ((qL[s]||0) + (qH[s]||0));
      });
      // extra corners and feet
      totals[widthVal] = (totals[widthVal] || 0) + 4;
      totals[0.5] = (totals[0.5] || 0) + 2;

      const ordered = Object.keys(totals).map(parseFloat).sort((a,b)=>a-b);
      let checklist = '';
      checklist += '<div><strong>Materials</strong></div>';
      checklist += '<div class="checklist">';
      ordered.forEach(size=>{
        const qty = totals[size];
        const colorClass =
          Math.abs(size - 2) < 1e-6 ? 'color-8' :
          Math.abs(size - 1) < 1e-6 ? 'color-4' :
          Math.abs(size - 0.5) < 1e-6 ? 'color-2' :
          'color-1';
        checklist += `
          <div class="checklist-item">
            <div class="color-box ${colorClass}" onclick="toggleStrikethrough(this)" aria-hidden="true"></div>
            <label onclick="toggleStrikethrough(this)">${qty} units of ${size} meters</label>
          </div>
        `;
      });
      checklist += '</div>';

      const dims = `<div style="margin-top:8px;"><strong>Outer size:</strong> ${lengthVal.toFixed(2)} m × ${heightVal.toFixed(2)} m &nbsp;|&nbsp; <strong>Truss width:</strong> ${widthVal} m</div>`;
      resultsEl.innerHTML = dims + checklist;

      // Debug
      let dbg = '';
      dbg += `topPieces: ${JSON.stringify(topPieces)}\n`;
      dbg += `leftPieces: ${JSON.stringify(leftPieces)}\n`;
      dbg += `cellsX x cellsY: ${cellsX} x ${cellsY}\n`;
      dbg += `cellSize(px): ${cellSize}\n`;
      dbg += `naturalW x naturalH(px): ${naturalW} x ${naturalH}\n`;
      el('debugInfo').textContent = dbg;
    }

    // Checklist toggle
    function toggleStrikethrough(elm){
      const label = elm.tagName === 'LABEL' ? elm : elm.nextElementSibling;
      label.classList.toggle('strikethrough');
    }
    window.toggleStrikethrough = toggleStrikethrough;

    // Download PNG (card)
    function downloadCard(){
      const card = el('exportCard');
      const title = (el('eventInput').value || 'truss-card').trim().replace(/[^\w\-]+/g,'_');
      // ensure white bg
      const prev = card.style.backgroundColor;
      card.style.backgroundColor = '#FFFFFF';
      html2canvas(card, {backgroundColor:'#FFFFFF', scale:2, useCORS:true}).then(canvas=>{
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = `${title}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        card.style.backgroundColor = prev || '';
      });
    }

    // ---------- Events ----------
    el('width').addEventListener('change', ()=>{
      state.trussWidth = parseFloat(el('width').value);
      syncStepsFromWidth();
    });

    // Height sync
    el('heightRange').addEventListener('input', e=> syncHeight(e.target.value));
    el('heightNum').addEventListener('input',   e=> syncHeight(e.target.value));

    // Length sync
    el('lengthRange').addEventListener('input', e=> syncLength(e.target.value));
    el('lengthNum').addEventListener('input',   e=> syncLength(e.target.value));

    // Buttons
    el('calcBtn').addEventListener('click', generateGrid);
    el('resetBtn').addEventListener('click', ()=>{
      syncHeight(0); syncLength(0);
      el('grid').innerHTML = '';
      el('results').innerHTML = '';
      el('debugInfo').textContent = '';
      el('eventInput').value = '';
      el('gridWrap').style.minHeight = window.matchMedia('(min-width:980px)').matches ? '440px' : '220px';
    });
    el('downloadBtn').addEventListener('click', downloadCard);

    // Initial setup
    (function init(){
      syncStepsFromWidth();
      syncHeight(0);
      syncLength(0);
    })();

    // Refit on resize
    window.addEventListener('resize', ()=>{
      if(el('grid').children.length) generateGrid();
    });
  </script>
</body>
</html>
