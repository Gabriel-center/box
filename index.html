<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Calculadora de Treliça Box</title>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    :root{
      --bg:#003366; --ink:#FFFFFF; --card:#FFFFFF; --brand:#0055cc; --accent:#0077cc;
      --muted:#f0f0f0; --line:#0077cc; --shadow:0 6px 18px rgba(0,0,0,.12); --radius:12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:Arial,sans-serif; color:var(--ink); background:var(--bg);
      display:flex; justify-content:center; align-items:flex-start; margin:0; padding:16px;
    }

    .page{width:100%; max-width:1200px; display:grid; grid-template-columns:1fr; gap:16px}
    @media (min-width:980px){ .page{grid-template-columns:380px 1fr; gap:18px} }

    .panel{background:var(--card); color:var(--brand); border-radius:var(--radius); box-shadow:var(--shadow); padding:16px}
    .panel h1{margin:0 0 10px; font-size:22px; color:var(--accent); text-align:center}

    .row{display:grid; grid-template-columns:1fr; gap:8px; margin:10px 0}
    label{font-size:14px}
    select,input,button{
      width:100%; padding:12px; border-radius:8px; border:1px solid var(--line); background:#fff; color:#000; font-size:14px;
    }
    input[type="range"]{accent-color:var(--accent)}
    .inline{display:grid; grid-template-columns:1fr 110px; gap:10px; align-items:center}

    .actions{display:flex; gap:10px; margin-top:10px; flex-wrap:wrap}
    .actions .grow{flex:1; min-width:180px}
    button.primary{background:var(--accent); color:#fff; border:1px solid var(--accent); cursor:pointer}
    button.primary:disabled{opacity:.6; cursor:not-allowed}

    @media (max-width:640px){
      .panel{padding:12px}
      .inline{grid-template-columns:1fr}
      select,input,button{padding:10px; font-size:16px}
      .actions{gap:8px}
    }

    /* Card exportável */
    .export-card{background:#fff; border:1px solid var(--muted); border-radius:var(--radius); padding:12px; color:#000}
    .export-header{display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap}
    .export-title{font-weight:bold; color:#000}
    .export-header input{flex:1 1 280px; border:1px solid var(--line); padding:10px; border-radius:8px; min-width:200px}

    .preview-wrap{display:grid; grid-template-columns:1fr; gap:12px}
    #gridWrap{overflow:hidden; border:1px solid #ddd; border-radius:10px; padding:8px; background:#fff; min-height:220px}
    #grid{position:relative; width:100%}

    /* Materiais – título com meta à direita + grid 2 colunas, ícones 32px */
    #results{background:var(--muted); border-radius:10px; padding:12px; color:#000; font-size:16px}
    .results-title{
      display:flex; align-items:center; gap:8px;
      margin:2px 0 10px;
    }
    .results-title .t-left{
      font-size:18px; font-weight:800; color:var(--accent);
      text-transform:uppercase; letter-spacing:.5px;
    }
    .results-title .title-rule{ flex:1; height:1px; background:var(--line); opacity:.35; }
    .results-title .t-meta{ font-weight:700; color:#222; white-space:nowrap; }

    .checklist{
      display:grid;
      grid-template-columns:repeat(2, minmax(0,1fr));
      gap:12px 16px;
      margin-top:10px;
    }
    .checklist-item{
      display:flex; align-items:center; gap:10px; cursor:pointer;
      user-select:none;
    }
    .checklist-item .sw{width:32px; height:32px; display:inline-block; flex:0 0 32px}
    .checklist-item label{flex:1}
    .checklist-item.off label{text-decoration:line-through; color:#666}
    .checklist-item.off .sw{opacity:.45}

    @media (max-width:520px){
      .checklist{grid-template-columns:1fr}
    }

    details{margin-top:12px; background:var(--muted); padding:10px 12px; border-radius:10px; color:#000}
    summary{cursor:pointer; font-weight:600; color:#000}
  </style>
</head>
<body>
  <div class="page">
    <!-- CONTROLES -->
    <section class="panel" aria-labelledby="calc-title">
      <h1 id="calc-title">Calculadora de Treliça Box</h1>

      <div class="row">
        <label for="width">Largura do perfil (metros)</label>
        <select id="width" aria-describedby="width-help">
          <option value="0.25" selected>0.25</option>
        </select>
        <small id="width-help" style="color:#2b2b2b">O passo dos controles segue esta largura.</small>
      </div>

      <!-- Comprimento (horizontal) primeiro -->
      <div class="row">
        <label>Comprimento (metros)</label>
        <div class="inline">
          <input aria-label="Comprimento (slider)" type="range" id="lengthRange" min="0" max="5" step="0.25" value="0">
          <!-- número sem max: soft cap -->
          <input aria-label="Comprimento (número)" type="number" id="lengthNum" min="0" step="0.25" value="0" inputmode="decimal" placeholder="ex.: 8">
        </div>
      </div>

      <div class="row">
        <label>Altura (metros)</label>
        <div class="inline">
          <input aria-label="Altura (slider)" type="range" id="heightRange" min="0" max="5" step="0.25" value="0">
          <!-- número sem max: soft cap -->
          <input aria-label="Altura (número)" type="number" id="heightNum" min="0" step="0.25" value="0" inputmode="decimal" placeholder="ex.: 3.5">
        </div>
      </div>

      <div class="actions">
        <button id="calcBtn" class="primary grow">Calcular grade e materiais</button>
        <button id="resetBtn" class="grow" title="Limpar">Limpar</button>
      </div>
    </section>

    <!-- PRÉVIA + RESULTADOS -->
    <section class="panel">
      <div class="export-card" id="exportCard">
        <div class="export-header">
          <span class="export-title">Evento/OS:</span>
          <input id="eventInput" type="text" placeholder="Opcional — título do cartão">
        </div>

        <div class="preview-wrap">
          <div id="gridWrap" aria-live="polite" aria-label="Prévia da treliça">
            <div id="grid"></div>
          </div>

          <div id="results" aria-label="Lista de materiais"></div>
        </div>
      </div>

      <!-- Botão de download FORA do card -->
      <div class="actions">
        <button id="downloadBtn" class="primary grow">Baixar cartão como PNG</button>
      </div>

      <details>
        <summary>Informações de depuração</summary>
        <div id="debugInfo" style="font-family:monospace; font-size:12px; white-space:pre-wrap;"></div>
      </details>
    </section>
  </div>

  <script>
    const VIEWPORT_CAP = 0.8;

    const state = { trussWidth:0.25, height:0, length:0, cellPxPerMeter:100, borderMarginPx:1, lastNW:0, lastNH:0 };
    const el = id => document.getElementById(id);
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const near = (a,b,eps=1e-6)=>Math.abs(a-b)<eps;
    const fmt = n => Number(n).toLocaleString('pt-BR',{maximumFractionDigits:2});
    const fmtInt = n => Number(n).toLocaleString('pt-BR',{maximumFractionDigits:0});
    const fmtMShort = n => `${Number(n).toLocaleString('pt-BR',{maximumFractionDigits:2})}m`;

    function syncStepsFromWidth(){
      const s=parseFloat(el('width').value);
      ['heightRange','lengthRange','heightNum','lengthNum'].forEach(id=>el(id).step=s);
    }

    // Split handlers: slider caps at 5; number can exceed 5
    function setHeightFromSlider(v){
      const val = clamp(parseFloat(v)||0, 0, 5);
      state.height = val;
      el('heightRange').value = val;
      el('heightNum').value = val;
    }
    function setHeightFromNumber(v){
      const val = Math.max(0, parseFloat(v)||0);
      state.height = val;
      el('heightNum').value = val;
      el('heightRange').value = Math.min(5, val);
    }
    function setLengthFromSlider(v){
      const val = clamp(parseFloat(v)||0, 0, 5);
      state.length = val;
      el('lengthRange').value = val;
      el('lengthNum').value = val;
    }
    function setLengthFromNumber(v){
      const val = Math.max(0, parseFloat(v)||0);
      state.length = val;
      el('lengthNum').value = val;
      el('lengthRange').value = Math.min(5, val);
    }

    // Materiais helpers
    function calcMateriais(dim, sizes){ const q={}; sizes.sort((a,b)=>b-a); sizes.forEach(s=>q[s]=0); let r=Math.max(0,+dim.toFixed(6));
      for(const s of sizes){ while(r+1e-9>=s){ q[s]++; r=+(r-s).toFixed(6); } } return q; }
    function distPecas(q, w){ const arr=[], ks=Object.keys(q).map(parseFloat).sort((a,b)=>b-a);
      for(const t of ks){ const c=q[t]||0, cells=Math.round(t/w), code=near(t,2)?'8':near(t,1)?'4':near(t,0.5)?'2':'1'; for(let i=0;i<c;i++) arr.push({code, cells}); }
      return arr;
    }

    // SVG helpers
    const SVGNS = 'http://www.w3.org/2000/svg';
    function makePatternDefs(){
      const defs = document.createElementNS(SVGNS,'defs');
      defs.innerHTML = `
        <pattern id="patRed" patternUnits="userSpaceOnUse" width="12" height="12">
          <path d="M-3,12 L12,-3 M0,15 L15,0" stroke="rgba(0,0,0,0.22)" stroke-width="4"/>
        </pattern>
        <pattern id="patOrange" patternUnits="userSpaceOnUse" width="10" height="10">
          <path d="M0,0 L0,10 M0,0 L10,0" stroke="rgba(0,0,0,0.18)" stroke-width="2"/>
        </pattern>
        <pattern id="patGreen" patternUnits="userSpaceOnUse" width="16" height="16">
          <circle cx="5" cy="5" r="2.5" fill="rgba(0,0,0,0.25)"/>
        </pattern>
        <pattern id="patBlue" patternUnits="userSpaceOnUse" width="16" height="16">
          <path d="M-4,16 L16,-4 M0,20 L20,0" stroke="rgba(255,255,255,0.28)" stroke-width="3"/>
        </pattern>`;
      return defs;
    }
    function baseColor(code){ return code==='8'?'#FF0000':code==='4'?'#ff6600':code==='2'?'#008000':code==='1'?'#0000FF':'#FFFFFF'; }
    function patId(code){ return code==='8'?'#patRed':code==='4'?'#patOrange':code==='2'?'#patGreen':code==='1'?'#patBlue':null; }

    function addPiece(svg, x,y,w,h, code){
      const g = document.createElementNS(SVGNS,'g');
      const r1 = document.createElementNS(SVGNS,'rect'); r1.setAttribute('x',x); r1.setAttribute('y',y); r1.setAttribute('width',w); r1.setAttribute('height',h); r1.setAttribute('fill', baseColor(code));
      g.appendChild(r1);
      const pid = patId(code);
      if(pid){
        const r2 = document.createElementNS(SVGNS,'rect'); r2.setAttribute('x',x); r2.setAttribute('y',y); r2.setAttribute('width',w); r2.setAttribute('height',h); r2.setAttribute('fill', `url(${pid})`);
        g.appendChild(r2);
      }
      const r3 = document.createElementNS(SVGNS,'rect'); r3.setAttribute('x',x+0.5); r3.setAttribute('y',y+0.5); r3.setAttribute('width',w-1); r3.setAttribute('height',h-1); r3.setAttribute('fill','none'); r3.setAttribute('stroke','#aaa'); r3.setAttribute('stroke-width','1');
      g.appendChild(r3);
      svg.appendChild(g);
    }

    // Box metrics
    function boxMetrics(elm, view=window){
      const cs = view.getComputedStyle(elm);
      const padL = parseFloat(cs.paddingLeft)||0, padR = parseFloat(cs.paddingRight)||0;
      const padT = parseFloat(cs.paddingTop)||0,  padB = parseFloat(cs.paddingBottom)||0;
      const borL = parseFloat(cs.borderLeftWidth)||0, borR = parseFloat(cs.borderRightWidth)||0;
      const borT = parseFloat(cs.borderTopWidth)||0,  borB = parseFloat(cs.borderBottomWidth)||0;
      const contentW = elm.clientWidth - padL - padR;
      return {padL,padR,padT,padB,borL,borR,borT,borB,contentW};
    }

    // Fit SVG into wrap
    function sizeSVGToFit(svg, nW, nH){
      const wrap = el('gridWrap');
      const card = el('exportCard');
      const m = boxMetrics(wrap);

      let scale = m.contentW / nW;
      const capH = window.innerHeight * VIEWPORT_CAP;
      const totalH = nH * scale + m.padT + m.padB + m.borT + m.borB;
      if (totalH > capH) {
        scale = (capH - (m.padT + m.padB + m.borT + m.borB)) / nH;
      }

      const targetW = Math.max(1, Math.round(nW * scale));
      const targetH = Math.max(1, Math.round(nH * scale));

      svg.setAttribute('width', targetW);
      svg.setAttribute('height', targetH);
      wrap.style.minHeight = (targetH + m.padT + m.padB) + 'px';
      wrap.style.overflow = 'hidden';

      wrap.dataset.scale = String(scale);
      wrap.dataset.nw = String(nW);
      wrap.dataset.nh = String(nH);
      wrap.dataset.tW = String(targetW);
      wrap.dataset.tH = String(targetH);
      wrap.dataset.padT = String(m.padT);
      wrap.dataset.padB = String(m.padB);
      wrap.dataset.padL = String(m.padL);
      wrap.dataset.padR = String(m.padR);
      wrap.dataset.borL = String(m.borL);
      wrap.dataset.borR = String(m.borR);
      wrap.dataset.cardW = String(card.getBoundingClientRect().width);
    }

    // Segmentação horizontal (considera largura EXTERNA)
    function segmentCells(innerCellsX, w, desiredSegs=1){
      const maxPer = Math.max(1, Math.floor((4-1e-9)/w));
      const segsByInner = Math.max(1, Math.ceil(innerCellsX / maxPer));
      const segs = Math.max(desiredSegs, segsByInner);
      const base = Math.floor(innerCellsX / segs);
      const rem  = innerCellsX % segs;
      const segCells = Array.from({length:segs}, (_,i)=> base + (i<rem?1:0));
      const bounds=[0]; for(let i=0;i<segs;i++) bounds.push(bounds[i]+segCells[i]);
      return {segs, segCells, bounds};
    }

    function gerarGrade(){
      const w = parseFloat(el('width').value), Hm=state.height, Wm=state.length;

      const innerL = Math.max(0, Wm - 2*w);
      const innerV = Math.max(0, Hm - 2*w);
      const innerCellsX = Math.max(0, Math.round(innerL / w + 1e-6));
      const innerCellsY = Math.max(0, Math.round(innerV / w + 1e-6));
      const cellsX = innerCellsX + 2, cellsY = innerCellsY + 2;

      // força segmentos pela largura EXTERNA
      const desiredSegs = Math.max(1, Math.ceil((Wm + 1e-9) / 4)); // 4.00 -> 2
      const {segs, segCells, bounds} = segmentCells(innerCellsX, w, desiredSegs);
      const supports = Math.max(0, segs-1);
      const supportCells = bounds.slice(1,-1);

      const sizes = [2,1,0.5,w];
      const qVert = calcMateriais(innerV, sizes);
      const sidePieces = distPecas(qVert, w);

      const cellPx = state.cellPxPerMeter * w; const m = state.borderMarginPx;
      const nW = cellsX*cellPx + 2*m, nH = cellsY*cellPx + 2*m;
      state.lastNW = nW; state.lastNH = nH;

      const grid = el('grid'); grid.innerHTML='';
      const svg = document.createElementNS(SVGNS,'svg');
      svg.setAttribute('viewBox', `0 0 ${nW} ${nH}`);
      svg.setAttribute('preserveAspectRatio','xMinYMin meet');
      svg.appendChild(makePatternDefs());
      grid.appendChild(svg);

      // cantos
      addPiece(svg, m, m, cellPx, cellPx, '1');
      addPiece(svg, m+(cellsX-1)*cellPx, m, cellPx, cellPx, '1');
      addPiece(svg, m, m+(cellsY-1)*cellPx, cellPx, cellPx, '1');
      addPiece(svg, m+(cellsX-1)*cellPx, m+(cellsY-1)*cellPx, cellPx, cellPx, '1');

      // topo/base por segmento
      for(let s=0;s<segs;s++){
        const start=bounds[s], len=segCells[s]; if(len<=0) continue;
        const meters=len*w; const q=calcMateriais(meters, sizes); const pieces=distPecas(q, w);

        let x = m + cellPx + start*cellPx;
        pieces.forEach(p=>{ const wpx=p.cells*cellPx; addPiece(svg, x, m, wpx, cellPx, p.code); x += wpx; });

        x = m + cellPx + start*cellPx;
        const yb = m + (cellsY-1)*cellPx;
        pieces.forEach(p=>{ const wpx=p.cells*cellPx; addPiece(svg, x, yb, wpx, cellPx, p.code); x += wpx; });
      }

      // colunas laterais
      function drawCol(x){ let y=m+cellPx; sidePieces.forEach(p=>{ const hp=p.cells*cellPx; addPiece(svg, x,y,cellPx,hp,p.code); y+=hp; }); }
      drawCol(m);
      drawCol(m+(cellsX-1)*cellPx);

      // miolo branco
      addPiece(svg, m+cellPx, m+cellPx, (cellsX-2)*cellPx, (cellsY-2)*cellPx, '0');

      // suportes internos + nós
      supportCells.forEach(pos=>{
        const x = m + cellPx + pos*cellPx;
        drawCol(x);
        addPiece(svg, x, m, cellPx, cellPx, '1');
        addPiece(svg, x, m+(cellsY-1)*cellPx, cellPx, cellPx, '1');
      });

      // dimensiona
      sizeSVGToFit(svg, nW, nH);

      // ===== Materiais =====
      const totals = {}; sizes.forEach(s=>totals[s]=0);

      // Verticais: laterais + suportes
      sizes.forEach(s=>{ totals[s] += (2 + supports) * (qVert[s] || 0); });

      // Horizontais: topo e base por segmento
      const sumSeg={}; sizes.forEach(s=>sumSeg[s]=0);
      for(let i=0;i<segs;i++){
        const meters=segCells[i]*w; const qi=calcMateriais(meters, sizes);
        sizes.forEach(s=>sumSeg[s]+=qi[s]||0);
      }
      sizes.forEach(s=>{ totals[s] += 2 * (sumSeg[s] || 0); });

      // Cantos
      totals[w] = (totals[w]||0) + 4;

      // Pés e Pesos (sempre mostrados)
      const colunas = supports + 2;
      const feetCount = colunas;       // 1 por coluna
      const weightCount = colunas * 2; // 2 por coluna

      // swatches padrão (cores+patterns) — 32px
      const sw = (code,side=32)=>(
        `<svg xmlns="http://www.w3.org/2000/svg" width="${side}" height="${side}" viewBox="0 0 ${side} ${side}">
           <defs>
             <pattern id="p1" patternUnits="userSpaceOnUse" width="12" height="12"><path d="M-3,12 L12,-3 M0,15 L15,0" stroke="rgba(0,0,0,0.22)" stroke-width="4"/></pattern>
             <pattern id="p2" patternUnits="userSpaceOnUse" width="10" height="10"><path d="M0,0 L0,10 M0,0 L10,0" stroke="rgba(0,0,0,0.18)" stroke-width="2"/></pattern>
             <pattern id="p3" patternUnits="userSpaceOnUse" width="16" height="16"><circle cx="5" cy="5" r="2.5" fill="rgba(0,0,0,0.25)"/></pattern>
             <pattern id="p4" patternUnits="userSpaceOnUse" width="16" height="16"><path d="M-4,16 L16,-4 M0,20 L20,0" stroke="rgba(255,255,255,0.28)" stroke-width="3"/></pattern>
           </defs>
           <rect width="${side}" height="${side}" fill="${baseColor(code)}"/>
           <rect width="${side}" height="${side}" fill="url(#${code==='8'?'p1':code==='4'?'p2':code==='2'?'p3':'p4'})"/>
           <rect x="0.5" y="0.5" width="${side-1}" height="${side-1}" fill="none" stroke="#777" stroke-width="1"/>
         </svg>`
      );

      // Ícones especiais — 32px
      const footIcon = (side=32)=>(
        `<svg xmlns="http://www.w3.org/2000/svg" width="${side}" height="${side}" viewBox="0 0 28 28">
          <rect x="5" y="5" width="6" height="16" fill="#555"/>
          <rect x="3" y="20" width="22" height="4" rx="1" ry="1" fill="#333"/>
          <circle cx="8" cy="9" r="2" fill="#999"/>
          <rect x="0.5" y="0.5" width="27" height="27" fill="none" stroke="#777" stroke-width="1"/>
        </svg>`
      );
      const weightIcon = (side=32)=>(
        `<svg xmlns="http://www.w3.org/2000/svg" width="${side}" height="${side}" viewBox="0 0 28 28">
          <rect x="6" y="12" width="16" height="4" rx="1" ry="1" fill="#444"/>
          <rect x="3" y="9" width="4" height="10" rx="1" ry="1" fill="#666"/>
          <rect x="21" y="9" width="4" height="10" rx="1" ry="1" fill="#666"/>
          <rect x="0.5" y="0.5" width="27" height="27" fill="none" stroke="#777" stroke-width="1"/>
        </svg>`
      );

      // Cabeçalho com meta "Q25 Xm × Ym"
      const qLabel = `Q${Math.round(w*100)}`;
      const meta = `${fmtMShort(Wm)} × ${fmtMShort(Hm)}`;
      let list = `
        <div class="results-title">
          <span class="t-left">Materiais</span>
          <span class="title-rule"></span>
          <span class="t-meta" id="resultsMeta">${qLabel} ${meta}</span>
        </div>
        <div class="checklist">`;

      // Mostrar todos os tamanhos (mesmo zero)
      const orderedAll = [w, 0.5, 1, 2].sort((a,b)=>a-b);
      orderedAll.forEach(t=>{
        const qnt = totals[t] || 0;
        const code = near(t,2)?'8':near(t,1)?'4':near(t,0.5)?'2':'1';
        list += `
          <div class="checklist-item" onclick="toggleItem(this)" role="button" tabindex="0">
            <span class="sw">${sw(code,32)}</span>
            <label>${fmtInt(qnt)} unidades de ${fmt(t)} metros</label>
          </div>`;
      });

      // Pés e Pesos (usando as variáveis já calculadas)
      list += `
        <div class="checklist-item" onclick="toggleItem(this)" role="button" tabindex="0">
          <span class="sw">${footIcon(32)}</span>
          <label>${fmtInt(feetCount)} Pés (0,5)</label>
        </div>
        <div class="checklist-item" onclick="toggleItem(this)" role="button" tabindex="0">
          <span class="sw">${weightIcon(32)}</span>
          <label>${fmtInt(weightCount)} Pesos</label>
        </div>`;

      list += '</div>';

      document.getElementById('results').innerHTML = list;
    }

    // Toggle riscado no item inteiro
    function toggleItem(node){ node.classList.toggle('off'); }

    function baixarCartao(){
      const card = el('exportCard');
      const wrapLive = el('gridWrap');
      let rawTitle = (el('eventInput').value || '').trim();
      if (!rawTitle) rawTitle = 'Qcoisa';
      const titulo = rawTitle.replace(/[^\w\-]+/g,'_');

      const tW  = parseFloat(wrapLive.dataset.tW)||0;
      const tH  = parseFloat(wrapLive.dataset.tH)||0;
      const padT= parseFloat(wrapLive.dataset.padT)||0;
      const padB= parseFloat(wrapLive.dataset.padB)||0;
      const padL= parseFloat(wrapLive.dataset.padL)||0;
      const padR= parseFloat(wrapLive.dataset.padR)||0;
      const borL= parseFloat(wrapLive.dataset.borL)||0;
      const borR= parseFloat(wrapLive.dataset.borR)||0;
      const cardW = parseFloat(wrapLive.dataset.cardW) || card.getBoundingClientRect().width;

      html2canvas(card, {
        backgroundColor:'#FFFFFF',
        scale: window.devicePixelRatio || 2,
        useCORS:true,
        onclone: (doc)=>{
          const cloneCard = doc.getElementById('exportCard');
          const wrap = cloneCard.querySelector('#gridWrap');
          const grid = cloneCard.querySelector('#grid');
          const svg  = grid.querySelector('svg');
          if(!svg) return;

          doc.documentElement.style.width = cardW + 'px';
          doc.body.style.width = cardW + 'px';
          cloneCard.style.width = cardW + 'px';

          svg.setAttribute('width',  tW);
          svg.setAttribute('height', tH);
          wrap.style.width = (tW + padL + padR + borL + borR) + 'px';
          wrap.style.minHeight = (tH + padT + padB) + 'px';
          wrap.style.overflow = 'hidden';
        }
      }).then(canvas=>{
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = `${titulo}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    }

    // Events
    el('width').addEventListener('change', ()=>{ state.trussWidth=parseFloat(el('width').value); syncStepsFromWidth(); });

    el('heightRange').addEventListener('input', e=> setHeightFromSlider(e.target.value));
    el('heightNum').addEventListener('input',   e=> setHeightFromNumber(e.target.value));
    el('lengthRange').addEventListener('input', e=> setLengthFromSlider(e.target.value));
    el('lengthNum').addEventListener('input',   e=> setLengthFromNumber(e.target.value));

    el('calcBtn').addEventListener('click', ()=>{ gerarGrade(); requestAnimationFrame(gerarGrade); });
    el('resetBtn').addEventListener('click', ()=>{
      setHeightFromNumber(0); setLengthFromNumber(0);
      el('grid').innerHTML=''; el('results').innerHTML=''; el('eventInput').value='';
      el('gridWrap').style.minHeight = '220px';
    });
    el('downloadBtn').addEventListener('click', baixarCartao);

    window.addEventListener('resize', ()=>{
      const grid = el('grid'); const svg = grid.querySelector('svg');
      if (!svg || !state.lastNW || !state.lastNH) return;
      sizeSVGToFit(svg, state.lastNW, state.lastNH);
    });

    (function(){
      syncStepsFromWidth();
      setLengthFromNumber(0);
      setHeightFromNumber(0);
    })();
  </script>
</body>
</html>
