<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Calculadora de Treliça Box</title>
  <!-- html2canvas para download -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    /* ====== PALETA (mantida) ====== */
    :root{
      --bg:#003366;         /* fundo da página */
      --ink:#FFFFFF;        /* texto sobre fundo escuro */
      --card:#FFFFFF;       /* cartões/brancos */
      --brand:#0055cc;      /* textos principais */
      --accent:#0077cc;     /* botões/títulos */
      --muted:#f0f0f0;      /* cinza claro */
      --line:#0077cc;       /* bordas */
      --shadow: 0 6px 18px rgba(0,0,0,.12);
      --radius: 12px;
    }

    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      font-family: Arial, sans-serif;
      color: var(--ink);
      background: var(--bg);
      display:flex;
      justify-content:center;
      align-items:flex-start;
      margin:0;
      padding:16px;
    }

    /* ====== Layout responsivo ====== */
    .page{
      width:100%;
      max-width:1200px;
      display:grid;
      grid-template-columns:1fr;
      gap:16px;
    }
    @media (min-width: 980px){
      .page{
        grid-template-columns: 380px 1fr; /* controles à esquerda, prévia à direita */
        gap:18px;
      }
    }

    /* ====== Painéis ====== */
    .panel{
      background: var(--card);
      color: var(--brand);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .panel h1{
      margin: 0 0 10px;
      font-size: 22px;
      color: var(--accent);
      text-align:center;
    }
    .panel h2{
      margin: 12px 0 8px;
      font-size: 18px;
      color: var(--accent);
    }

    /* ====== Controles ====== */
    .row{ display:grid; grid-template-columns: 1fr; gap:8px; margin:10px 0 }
    label{ font-size: 14px }
    select,input,button{
      width:100%;
      padding:12px;
      border-radius:8px;
      border:1px solid var(--line);
      background:#fff;
      color:#000;
      font-size:14px;
    }
    input[type="range"]{ accent-color: var(--accent) }

    .inline{
      display:grid;
      grid-template-columns: 1fr 110px;
      gap:10px;
      align-items:center;
    }
    .actions{
      display:flex;
      gap:10px;
      margin-top:10px;
      flex-wrap: wrap;
    }
    .actions .grow{ flex:1; min-width: 180px }
    button.primary{
      background: var(--accent);
      color:#fff;
      border:1px solid var(--accent);
      cursor:pointer;
    }
    button.primary:disabled{ opacity:.6; cursor:not-allowed }

    /* ====== Mobile tune ====== */
    @media (max-width: 640px){
      .panel{ padding: 12px }
      .inline{ grid-template-columns: 1fr; }           /* empilha slider e número */
      select,input,button{ padding:10px; font-size:16px } /* alvo de toque melhor */
      .actions{ gap:8px }
    }

    /* ====== Card de exportação ====== */
    .export-card{
      background: #fff;
      border:1px solid var(--muted);
      border-radius: var(--radius);
      padding: 12px;
      color:#000;
    }
    .export-header{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:10px;
      flex-wrap: wrap;
    }
    .export-title{ font-weight:bold; color:#000 }
    .export-header input{
      flex:1 1 280px;
      border:1px solid var(--line);
      padding:10px;
      border-radius:8px;
      min-width: 200px;
    }

    /* ====== Prévia da treliça ====== */
    .preview-wrap{
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    #gridWrap{
      overflow:hidden;
      border:1px solid #ddd;
      border-radius:10px;
      padding:8px;
      background:#fff;
      min-height: 220px;
    }
    @media (min-width: 980px){
      #gridWrap{ min-height: 440px }
    }
    #grid{
      position: relative;
      white-space: nowrap;
      width: 100%;
      height: 100%;
      transform-origin: top left;
    }

    /* ====== Peças + padrões acessíveis ====== */
    .truss-piece{
      position:absolute;
      box-sizing:border-box;
      outline:1px solid #aaa;
      outline-offset:-1px;
      image-rendering: pixelated;
    }

    /* 2.0 m -> vermelho com listras diagonais */
    .color-8{
      background:
        repeating-linear-gradient(45deg, rgba(0,0,0,.18) 0 6px, rgba(0,0,0,0) 6px 12px),
        #FF0000;
    }
    /* 1.0 m -> laranja com hatch cruzado */
    .color-4{
      background:
        repeating-linear-gradient(90deg, rgba(0,0,0,.16) 0 5px, rgba(0,0,0,0) 5px 10px),
        repeating-linear-gradient(0deg,  rgba(0,0,0,.12) 0 5px, rgba(0,0,0,0) 5px 10px),
        #ff6600;
    }
    /* 0.5 m -> verde com pontilhado */
    .color-2{
      background:
        radial-gradient(circle at 6px 6px, rgba(0,0,0,.22) 2px, transparent 2px),
        radial-gradient(circle at 18px 18px, rgba(0,0,0,.22) 2px, transparent 2px),
        #008000;
      background-size: 24px 24px, 24px 24px, auto;
    }
    /* Outros -> azul com diagonal larga */
    .color-1{
      background:
        repeating-linear-gradient(135deg, rgba(255,255,255,.25) 0 8px, rgba(255,255,255,0) 8px 16px),
        #0000FF;
      cursor:pointer;
    }
    .color-0{ background:#FFFFFF }

    /* ====== Resultados ====== */
    #results{
      background: var(--muted);
      border-radius:10px;
      padding:12px;
      color:#000;
      font-size:16px;
    }
    .checklist{ margin-top:8px }
    .checklist-item{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
      white-space:nowrap;
    }
    .color-box{
      width:28px;
      height:28px;
      border:1px solid #999;
      cursor:pointer;
      border-radius:4px;
      image-rendering: pixelated;
    }
    .checklist-item label{
      flex:1;
      cursor:pointer;
    }
    .checklist-item label.strikethrough{
      text-decoration: line-through;
      color:#666;
    }

    /* ====== Legenda ====== */
    .legend{
      display:grid;
      grid-template-columns: repeat(4, minmax(120px, 1fr));
      gap:10px;
      margin-top:6px;
      font-size:13px;
      color:#000;
    }
    .legend-item{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .legend-swatch{
      width:18px;
      height:18px;
      border:1px solid #777;
      border-radius:3px;
    }

    /* ====== Debug ====== */
    details{
      margin-top:12px;
      background: var(--muted);
      padding:10px 12px;
      border-radius:10px;
      color:#000;
    }
    summary{
      cursor:pointer;
      font-weight:600;
      color:#000;
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- ESQUERDA: Controles -->
    <section class="panel" aria-labelledby="calc-title">
      <h1 id="calc-title">Calculadora de Treliça Box</h1>

      <div class="row">
        <label for="width">Largura do perfil (metros)</label>
        <select id="width" aria-describedby="width-help">
          <option value="0.25" selected>0.25</option>
        </select>
        <small id="width-help" style="color:#2b2b2b">O passo dos controles segue esta largura.</small>
      </div>

      <div class="row">
        <label>Altura (metros)</label>
        <div class="inline">
          <input aria-label="Altura (slider)" type="range" id="heightRange" min="0" max="30" step="0.25" value="0">
          <input aria-label="Altura (número)" type="number" id="heightNum" min="0" max="30" step="0.25" value="0" inputmode="decimal">
        </div>
      </div>

      <div class="row">
        <label>Comprimento (metros)</label>
        <div class="inline">
          <input aria-label="Comprimento (slider)" type="range" id="lengthRange" min="0" max="30" step="0.25" value="0">
          <input aria-label="Comprimento (número)" type="number" id="lengthNum" min="0" max="30" step="0.25" value="0" inputmode="decimal">
        </div>
      </div>

      <div class="actions">
        <button id="calcBtn" class="primary grow">Calcular grade e materiais</button>
        <button id="resetBtn" class="grow" title="Limpar">Limpar</button>
      </div>
    </section>

    <!-- DIREITA: Prévia + Resultados -->
    <section class="panel">
      <div class="export-card" id="exportCard">
        <div class="export-header">
          <span class="export-title">Evento/OS:</span>
          <input id="eventInput" type="text" placeholder="Opcional — título do cartão">
        </div>

        <div class="preview-wrap">
          <div id="gridWrap" aria-live="polite" aria-label="Prévia da treliça">
            <div id="grid"></div>
          </div>

          <div class="legend" aria-label="Legenda">
            <div class="legend-item">
              <span class="legend-swatch color-8"></span><span>2,0 m</span>
            </div>
            <div class="legend-item">
              <span class="legend-swatch color-4"></span><span>1,0 m</span>
            </div>
            <div class="legend-item">
              <span class="legend-swatch color-2"></span><span>0,5 m</span>
            </div>
            <div class="legend-item">
              <span class="legend-swatch color-1"></span><span>Outros</span>
            </div>
          </div>

          <div id="results" aria-label="Lista de materiais"></div>

          <div class="actions">
            <button id="downloadBtn" class="primary grow">Baixar cartão como PNG</button>
          </div>
        </div>
      </div>

      <details>
        <summary>Informações de depuração</summary>
        <div id="debugInfo" style="font-family: monospace; font-size:12px; white-space: pre-wrap;"></div>
      </details>
    </section>
  </div>

  <script>
    // ---------- Estado ----------
    const state = {
      trussWidth: 0.25,
      height: 0,
      length: 0,
      cellPxPerMeter: 100,   // px por metro para 1,0 m; multiplicado pela largura do perfil
      borderMarginPx: 1
    };

    // ---------- Utilidades ----------
    const el = id => document.getElementById(id);
    const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
    const near = (a,b,eps=1e-6) => Math.abs(a-b) < eps;

    function syncStepsFromWidth(){
      const step = parseFloat(el('width').value);
      ['heightRange','lengthRange','heightNum','lengthNum'].forEach(id=>{
        el(id).step = step;
      });
    }

    function syncHeight(v){
      const val = parseFloat(v);
      state.height = clamp(isNaN(val)?0:val, 0, 1000);
      el('heightRange').value = state.height;
      el('heightNum').value = state.height;
    }
    function syncLength(v){
      const val = parseFloat(v);
      state.length = clamp(isNaN(val)?0:val, 0, 1000);
      el('lengthRange').value = state.length;
      el('lengthNum').value = state.length;
    }

    // Corte guloso de materiais (tamanhos descendentes)
    function calcularMateriaisParaDimensao(dim, tamanhos){
      const q = {};
      tamanhos.sort((a,b)=>b-a);
      tamanhos.forEach(s=>q[s]=0);
      let restante = Math.max(0, +dim.toFixed(6));
      for(const s of tamanhos){
        while(restante + 1e-9 >= s){
          q[s]++;
          restante = +(restante - s).toFixed(6);
        }
      }
      return q;
    }

    // Converte quantidades em peças com "células" e "código" de cor/padrão
    function distribuirPecas(qtds, larguraPerfil){
      const pecas = [];
      const tamanhos = Object.keys(qtds).map(parseFloat).sort((a,b)=>b-a);
      for(const t of tamanhos){
        const count = qtds[t] || 0;
        const celulas = Math.round(t / larguraPerfil);
        const code =
          near(t,2)   ? '8' :
          near(t,1)   ? '4' :
          near(t,0.5) ? '2' : '1';
        for(let i=0;i<count;i++) pecas.push({code, cells: celulas});
      }
      return pecas;
    }

    function criarPeca(x,y,w,h,code,z=1){
      const d = document.createElement('div');
      d.className = 'truss-piece color-' + code;
      d.style.left = x + 'px';
      d.style.top = y + 'px';
      d.style.width = w + 'px';
      d.style.height = h + 'px';
      d.style.zIndex = z;
      return d;
    }

    // Ajusta escala da prévia para caber no contêiner
    function ajustarEscala(larguraNatural, alturaNatural){
      const wrap = el('gridWrap');
      const padding = 20;
      const dispW = wrap.clientWidth - padding;
      const dispH = wrap.clientHeight - padding || 440;
      const sx = dispW / larguraNatural;
      const sy = dispH / alturaNatural;
      const escala = Math.min(1, sx, sy);
      const grid = el('grid');
      grid.style.width = larguraNatural + 'px';
      grid.style.height = alturaNatural + 'px';
      grid.style.transform = 'scale(' + escala + ')';
      const usadoH = Math.min(alturaNatural * escala + 12, Math.max(dispH, 220));
      wrap.style.minHeight = usadoH + 'px';
    }

    // Segmentação inteira em células para garantir vãos < 4 m e alinhamento exato
    function segmentarCelulas(innerCellsX, larguraPerfil){
      const maxCelulasPorTrecho = Math.max(1, Math.floor((4 - 1e-9) / larguraPerfil));
      const segmentos = Math.max(1, Math.ceil(innerCellsX / maxCelulasPorTrecho));
      const base = Math.floor(innerCellsX / segmentos);
      const resto = innerCellsX % segmentos;
      const celSeg = Array.from({length: segmentos}, (_,i)=> base + (i < resto ? 1 : 0));
      const limites = [0];
      for(let i=0;i<segmentos;i++) limites.push(limites[i] + celSeg[i]);
      return {segmentos, celSeg, limites};
    }

    // ---------- Construtor principal ----------
    function gerarGrade(){
      const larguraPerfil  = parseFloat(el('width').value);
      const altura = state.height;
      const comprimento = state.length;

      const resEl = el('results');
      resEl.innerHTML = '';

      if(comprimento < larguraPerfil*2 || altura < larguraPerfil*2){
        resEl.innerHTML = '<div><strong>Dica:</strong> comprimento e altura devem ser pelo menos 2× a largura do perfil.</div>';
      }

      // Vãos internos (entre colunas de canto)
      const vaoInternoX = Math.max(0, comprimento - larguraPerfil*2);
      const vaoInternoY = Math.max(0, altura - larguraPerfil*2);

      // Trabalhando em células inteiras
      const innerCellsX = Math.max(0, Math.round(vaoInternoX / larguraPerfil + 1e-6));
      const innerCellsY = Math.max(0, Math.round(vaoInternoY / larguraPerfil + 1e-6));
      const cellsX = innerCellsX + 2;
      const cellsY = innerCellsY + 2;

      const {segmentos, celSeg, limites} = segmentarCelulas(innerCellsX, larguraPerfil);
      const suportes = Math.max(0, segmentos - 1);
      const posSuportes = limites.slice(1, -1); // remove 0 e innerCellsX

      const tamanhos = [2, 1, 0.5, larguraPerfil];

      // Peças verticais (laterais/suportes)
      const qVert = calcularMateriaisParaDimensao(vaoInternoY, tamanhos);
      const pecasLaterais = distribuirPecas(qVert, larguraPerfil);

      const tamCelula = state.cellPxPerMeter * larguraPerfil; // px por célula
      const m = state.borderMarginPx;

      const larguraNatural = cellsX * tamCelula + 2*m;
      const alturaNatural  = cellsY * tamCelula + 2*m;

      const grid = el('grid');
      grid.innerHTML = '';

      // Cantos
      grid.appendChild(criarPeca(m, m, tamCelula, tamCelula, '1', 3));
      grid.appendChild(criarPeca(m + (cellsX-1)*tamCelula, m, tamCelula, tamCelula, '1', 3));
      grid.appendChild(criarPeca(m, m + (cellsY-1)*tamCelula, tamCelula, tamCelula, '1', 3));
      grid.appendChild(criarPeca(m + (cellsX-1)*tamCelula, m + (cellsY-1)*tamCelula, tamCelula, tamCelula, '1', 3));

      // Bordas superior e inferior por segmento (alinhadas às células inteiras)
      for(let s=0; s<segmentos; s++){
        const inicioCel = limites[s];
        const celulasTrecho = celSeg[s];
        if(celulasTrecho<=0) continue;

        const metrosTrecho = celulasTrecho * larguraPerfil;
        const qTrecho = calcularMateriaisParaDimensao(metrosTrecho, tamanhos);
        const pecasTrecho = distribuirPecas(qTrecho, larguraPerfil);

        // Topo
        let xTop = m + tamCelula + inicioCel * tamCelula;
        pecasTrecho.forEach(p=>{
          const w = p.cells * tamCelula;
          grid.appendChild(criarPeca(xTop, m, w, tamCelula, p.code, 1));
          xTop += w;
        });

        // Base
        let xBase = m + tamCelula + inicioCel * tamCelula;
        const yBase = m + (cellsY-1)*tamCelula;
        pecasTrecho.forEach(p=>{
          const w = p.cells * tamCelula;
          grid.appendChild(criarPeca(xBase, yBase, w, tamCelula, p.code, 1));
          xBase += w;
        });
      }

      // Colunas esquerda e direita
      function desenharColunaVertical(x, z=2){
        let y = m + tamCelula;
        pecasLaterais.forEach(p=>{
          const h = p.cells * tamCelula;
          grid.appendChild(criarPeca(x, y, tamCelula, h, p.code, z));
          y += h;
        });
      }
      desenharColunaVertical(m, 2);                                   // esquerda
      desenharColunaVertical(m + (cellsX-1)*tamCelula, 2);            // direita

      // Miolo branco
      grid.appendChild(criarPeca(m + tamCelula, m + tamCelula, (cellsX-2)*tamCelula, (cellsY-2)*tamCelula, '0', 0));

      // Suportes internos + nós sobrepostos (garante alinhamento visual)
      posSuportes.forEach(pos=>{
        const xSup = m + tamCelula + pos * tamCelula;
        desenharColunaVertical(xSup, 2);
        grid.appendChild(criarPeca(xSup, m, tamCelula, tamCelula, '1', 4));                               // nó topo
        grid.appendChild(criarPeca(xSup, m + (cellsY-1)*tamCelula, tamCelula, tamCelula, '1', 4));        // nó base
      });

      // Ajusta escala para caber
      ajustarEscala(larguraNatural, alturaNatural);

      // ===== Materiais =====
      const totais = {};
      tamanhos.forEach(s=>totais[s]=0);

      // Verticais: 2 laterais + suportes internos
      tamanhos.forEach(s=>{
        totais[s] += (2 + suportes) * (qVert[s] || 0);
      });

      // Horizontais: soma por segmento, depois ×2 (topo e base)
      const somaSeg = {};
      tamanhos.forEach(s=>somaSeg[s]=0);
      for(let s=0; s<segmentos; s++){
        const metrosTrecho = celSeg[s] * larguraPerfil;
        const qTrecho = calcularMateriaisParaDimensao(metrosTrecho, tamanhos);
        tamanhos.forEach(sz=>{
          somaSeg[sz] += qTrecho[sz] || 0;
        });
      }
      tamanhos.forEach(s=>{
        totais[s] += 2 * (somaSeg[s] || 0);
      });

      // Extras (pés/cantos etc.)
      totais[larguraPerfil] = (totais[larguraPerfil] || 0) + 4;
      totais[0.5] = (totais[0.5] || 0) + 2;

      // Render lista
      const ordenado = Object.keys(totais).map(parseFloat).sort((a,b)=>a-b);
      let checklist = '';
      checklist += '<div><strong>Materiais</strong></div>';
      checklist += '<div class="checklist">';
      ordenado.forEach(t=>{
        const q = totais[t];
        const cls =
          near(t,2)   ? 'color-8' :
          near(t,1)   ? 'color-4' :
          near(t,0.5) ? 'color-2' : 'color-1';
        checklist += `
          <div class="checklist-item">
            <div class="color-box ${cls}" onclick="alternarRisco(this)" aria-hidden="true"></div>
            <label onclick="alternarRisco(this)">${q} unidades de ${t} metros</label>
          </div>
        `;
      });
      checklist += '</div>';

      const dims = `<div style="margin-top:8px;">
        <strong>Tamanho externo:</strong> ${comprimento.toFixed(2)} m × ${altura.toFixed(2)} m
        &nbsp;|&nbsp; <strong>Largura do perfil:</strong> ${larguraPerfil} m
        &nbsp;|&nbsp; <strong>Seções:</strong> ${segmentos} (vão máximo < 4 m)
      </div>`;
      resEl.innerHTML = dims + checklist;

      // Debug
      let dbg = '';
      dbg += `vaoInternoX(m): ${vaoInternoX.toFixed(3)} | vaoInternoY(m): ${vaoInternoY.toFixed(3)}\n`;
      dbg += `cellsX x cellsY: ${cellsX} x ${cellsY}\n`;
      dbg += `innerCellsX: ${innerCellsX} | innerCellsY: ${innerCellsY}\n`;
      dbg += `segmentos: ${segmentos} | suportes: ${suportes}\n`;
      dbg += `limites (células): [${limites.join(', ')}]\n`;
      el('debugInfo').textContent = dbg;
    }

    // Alterna risco (checklist)
    function alternarRisco(elm){
      const label = elm.tagName === 'LABEL' ? elm : elm.nextElementSibling;
      label.classList.toggle('strikethrough');
    }
    window.alternarRisco = alternarRisco;

    // Download PNG
    function baixarCartao(){
      const card = el('exportCard');
      const titulo = (el('eventInput').value || 'trelica-card').trim().replace(/[^\w\-]+/g,'_');
      const prev = card.style.backgroundColor;
      card.style.backgroundColor = '#FFFFFF';
      html2canvas(card, {backgroundColor:'#FFFFFF', scale:2, useCORS:true}).then(canvas=>{
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = `${titulo}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        card.style.backgroundColor = prev || '';
      });
    }

    // ---------- Eventos ----------
    el('width').addEventListener('change', ()=>{
      state.trussWidth = parseFloat(el('width').value);
      syncStepsFromWidth();
    });

    // Sincroniza altura
    el('heightRange').addEventListener('input', e=> syncHeight(e.target.value));
    el('heightNum').addEventListener('input',   e=> syncHeight(e.target.value));

    // Sincroniza comprimento
    el('lengthRange').addEventListener('input', e=> syncLength(e.target.value));
    el('lengthNum').addEventListener('input',   e=> syncLength(e.target.value));

    // Botões
    el('calcBtn').addEventListener('click', ()=>{
      // Redesenha duas vezes como você pediu
      gerarGrade();
      // uma batida no próximo frame garante medidas/resize aplicados
      requestAnimationFrame(gerarGrade);
    });

    el('resetBtn').addEventListener('click', ()=>{
      syncHeight(0); syncLength(0);
      el('grid').innerHTML = '';
      el('results').innerHTML = '';
      el('debugInfo').textContent = '';
      el('eventInput').value = '';
      el('gridWrap').style.minHeight = window.matchMedia('(min-width:980px)').matches ? '440px' : '220px';
    });

    el('downloadBtn').addEventListener('click', baixarCartao);

    // Setup inicial
    (function init(){
      syncStepsFromWidth();
      syncHeight(0);
      syncLength(0);
    })();

    // Reajusta em resize
    window.addEventListener('resize', ()=>{
      if(el('grid').children.length) gerarGrade();
    });
  </script>
</body>
</html>
